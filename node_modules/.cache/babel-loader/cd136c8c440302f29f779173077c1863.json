{"ast":null,"code":"/*! multi-integer-range (c) 2015 Soichiro Miki */\n\"use strict\";\n\nvar MultiRange = function () {\n  /**\n   * Creates a new MultiRange object.\n   */\n  function MultiRange(data) {\n    function isArray(x) {\n      return Object.prototype.toString.call(x) === '[object Array]';\n    }\n\n    this.ranges = [];\n\n    if (typeof data === 'string') {\n      this.parseString(data);\n    } else if (typeof data === 'number') {\n      this.appendRange(data, data);\n    } else if (data instanceof MultiRange) {\n      this.ranges = data.getRanges();\n    } else if (isArray(data)) {\n      for (var _i = 0, _a = data; _i < _a.length; _i++) {\n        var item = _a[_i];\n\n        if (isArray(item)) {\n          if (item.length === 2) {\n            this.appendRange(item[0], item[1]);\n          } else {\n            throw new TypeError('Invalid array initializer');\n          }\n        } else if (typeof item === 'number') {\n          this.append(item);\n        } else {\n          throw new TypeError('Invalid array initialzer');\n        }\n      }\n    } else if (data !== undefined) {\n      throw new TypeError('Invalid input');\n    }\n  }\n  /**\n   * Parses the initialize string and build the range data.\n   * Override this if you need to customize the parsing strategy.\n   */\n\n\n  MultiRange.prototype.parseString = function (data) {\n    function toInt(str) {\n      var m = str.match(/^\\(?(\\-?\\d+)/);\n      return parseInt(m[1], 10);\n    }\n\n    var s = data.replace(/\\s/g, '');\n    if (!s.length) return;\n    var match;\n\n    for (var _i = 0, _a = s.split(','); _i < _a.length; _i++) {\n      var r = _a[_i];\n\n      if (match = r.match(/^(\\d+|\\(\\-?\\d+\\))$/)) {\n        var val = toInt(match[1]);\n        this.appendRange(val, val);\n      } else if (match = r.match(/^(\\d+|\\(\\-?\\d+\\))?\\-(\\d+|\\(\\-?\\d+\\))?$/)) {\n        var min = match[1] === undefined ? -Infinity : toInt(match[1]);\n        var max = match[2] === undefined ? +Infinity : toInt(match[2]);\n        this.appendRange(min, max);\n      } else {\n        throw new SyntaxError('Invalid input');\n      }\n    }\n\n    ;\n  };\n  /**\n   * Clones this instance.\n   */\n\n\n  MultiRange.prototype.clone = function () {\n    return new MultiRange(this);\n  };\n  /**\n   * Appends to this instance.\n   * @parasm value The data to append.\n   */\n\n\n  MultiRange.prototype.append = function (value) {\n    if (value === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (value instanceof MultiRange) {\n      for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n        var r = _a[_i];\n        this.appendRange(r[0], r[1]);\n      }\n\n      return this;\n    } else {\n      return this.append(new MultiRange(value));\n    }\n  };\n  /**\n   * Appends a specified range of integers to this isntance.\n   * @param min The minimum value of the range to append.\n   * @param max The minimum value of the range to append.\n   */\n\n\n  MultiRange.prototype.appendRange = function (min, max) {\n    var newRange = [min, max];\n\n    if (newRange[0] > newRange[1]) {\n      newRange = [newRange[1], newRange[0]];\n    }\n\n    if (newRange[0] === Infinity && newRange[1] === Infinity || newRange[0] === -Infinity && newRange[1] === -Infinity) {\n      throw new RangeError('Infinity can be used only within an unbounded range segment');\n    }\n\n    var overlap = this.findOverlap(newRange);\n    this.ranges.splice(overlap.lo, overlap.count, overlap.union);\n    return this;\n  };\n  /**\n   * Subtracts from this instance.\n   * @param value The data to subtract.\n   */\n\n\n  MultiRange.prototype.subtract = function (value) {\n    if (value === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (value instanceof MultiRange) {\n      for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n        var r = _a[_i];\n        this.subtractRange(r[0], r[1]);\n      }\n\n      return this;\n    } else {\n      return this.subtract(new MultiRange(value));\n    }\n  };\n  /**\n   * Subtracts a specified range of integers from this instance.\n   * @param min The minimum value of the range to subtract.\n   * @param max The minimum value of the range to subtract.\n   */\n\n\n  MultiRange.prototype.subtractRange = function (min, max) {\n    var newRange = [min, max];\n\n    if (newRange[0] > newRange[1]) {\n      newRange = [newRange[1], newRange[0]];\n    }\n\n    var overlap = this.findOverlap(newRange);\n\n    if (overlap.count > 0) {\n      var remain = [];\n\n      if (this.ranges[overlap.lo][0] < newRange[0]) {\n        remain.push([this.ranges[overlap.lo][0], newRange[0] - 1]);\n      }\n\n      if (newRange[1] < this.ranges[overlap.lo + overlap.count - 1][1]) {\n        remain.push([newRange[1] + 1, this.ranges[overlap.lo + overlap.count - 1][1]]);\n      }\n\n      this.ranges.splice.apply(this.ranges, [overlap.lo, overlap.count].concat(remain));\n    }\n\n    return this;\n  };\n  /**\n   * Remove integers which are not included in the given ranges (aka intersection).\n   * @param value The data to calculate the intersetion.\n   */\n\n\n  MultiRange.prototype.intersect = function (value) {\n    if (value === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (value instanceof MultiRange) {\n      var result = [];\n      var jstart = 0; // used for optimization\n\n      for (var i = 0; i < this.ranges.length; i++) {\n        var r1 = this.ranges[i];\n\n        for (var j = jstart; j < value.ranges.length; j++) {\n          var r2 = value.ranges[j];\n\n          if (r1[0] <= r2[1] && r1[1] >= r2[0]) {\n            jstart = j;\n            var min = Math.max(r1[0], r2[0]);\n            var max = Math.min(r1[1], r2[1]);\n            result.push([min, max]);\n          } else if (r1[1] < r2[0]) {\n            break;\n          }\n        }\n      }\n\n      this.ranges = result;\n      return this;\n    } else {\n      return this.intersect(new MultiRange(value));\n    }\n  };\n  /**\n   * Determines how the given range overlaps or touches the existing ranges.\n   * This is a helper method that calculates how an append/subtract operation\n   * affects the existing range members.\n   * @param target The range array to test.\n   * @return An object containing information about how the given range\n   * overlaps or touches this instance.\n   */\n\n\n  MultiRange.prototype.findOverlap = function (target) {\n    //   a        b  c     d         e  f       g h i   j k  l       m\n    //--------------------------------------------------------------------\n    //   |----(0)----|     |---(1)---|  |---(2)---|          |--(3)--|\n    //            |------------(A)--------------|\n    //                                            |-(B)-|\n    //                                              |-(C)-|\n    //\n    // (0)-(3) represent the existing ranges (this.ranges),\n    // and (A)-(C) are the ranges being passed to this function.\n    //\n    // A pseudocode findOverlap(A) returns { lo: 0, count: 3, union: <a-h> },\n    // meaning (A) overlaps the 3 existing ranges from index 0.\n    //\n    // findOverlap(B) returns { lo: 2, count: 1, union: <f-j> },\n    // meaning (B) \"touches\" one range element, (2).\n    //\n    // findOverlap(C) returns { lo: 3, count: 0, union: <i-k> }\n    // meaning (C) is between (2) and (3) but overlaps/touches neither of them.\n    for (var hi = this.ranges.length - 1; hi >= 0; hi--) {\n      var r = this.ranges[hi];\n      var union = void 0;\n\n      if (union = this.calcUnion(r, target)) {\n        var count = 1;\n        var tmp = void 0;\n\n        while (hi - count >= 0 && (tmp = this.calcUnion(union, this.ranges[hi - count]))) {\n          union = tmp;\n          count++;\n        } // The given target touches or overlaps one or more of the existing ranges\n\n\n        return {\n          lo: hi + 1 - count,\n          count: count,\n          union: union\n        };\n      } else if (r[1] < target[0]) {\n        // The given target does not touch nor overlap the existing ranges\n        return {\n          lo: hi + 1,\n          count: 0,\n          union: target\n        };\n      }\n    } // The given target is smaller than the smallest existing range\n\n\n    return {\n      lo: 0,\n      count: 0,\n      union: target\n    };\n  };\n  /**\n   * Calculates the union of two specified ranges.\n   * @param a Range A\n   * @param b Range B\n   * @return Union of a and b. Null if a and b do not touch nor intersect.\n   */\n\n\n  MultiRange.prototype.calcUnion = function (a, b) {\n    if (a[1] + 1 < b[0] || a[0] - 1 > b[1]) {\n      return null; // cannot make union\n    }\n\n    return [Math.min(a[0], b[0]), Math.max(a[1], b[1])];\n  };\n  /**\n   * Exports the whole range data as an array of arrays.\n   */\n\n\n  MultiRange.prototype.getRanges = function () {\n    var result = [];\n\n    for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n      var r = _a[_i];\n      result.push([r[0], r[1]]);\n    }\n\n    return result;\n  };\n  /**\n   * Checks if the instance contains the specified value.\n   * @param value Value to be checked\n   * @return True if the specified value is included in the instance.\n   */\n\n\n  MultiRange.prototype.has = function (value) {\n    if (value === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (value instanceof MultiRange) {\n      var s = 0;\n      var len = this.ranges.length;\n\n      for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n        var tr = _a[_i];\n        var i = void 0;\n\n        for (i = s; i < len; i++) {\n          var my = this.ranges[i];\n          if (tr[0] >= my[0] && tr[1] <= my[1] && tr[1] >= my[0] && tr[1] <= my[1]) break;\n        }\n\n        if (i === len) return false;\n      }\n\n      return true;\n    } else {\n      return this.has(new MultiRange(value));\n    }\n  };\n  /**\n   * Checks if the instance contains the range specified by the two parameters.\n   * @param min The minimum value of the range to subtract.\n   * @param max The minimum value of the range to subtract.\n   * @return True if the specified value is included in the instance.\n   */\n\n\n  MultiRange.prototype.hasRange = function (min, max) {\n    return this.has(new MultiRange([[min, max]]));\n  };\n  /**\n   * Returns the number of range segments.\n   * For example, the segmentLength of `2-5,7,9-11' is 3.\n   * Returns 0 for an empty instance.\n   * @return The number of segments.\n   */\n\n\n  MultiRange.prototype.segmentLength = function () {\n    return this.ranges.length;\n  };\n  /**\n   * Calculates how many numbers are effectively included in this instance.\n   * (i.e. '1-10,51-60,90' returns 21)\n   * @return The number of integer values in this instance.\n   *    Returns `Infinity` for unbounded ranges.\n   */\n\n\n  MultiRange.prototype.length = function () {\n    if (this.isUnbounded()) return Infinity;\n    var result = 0;\n\n    for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n      var r = _a[_i];\n      result += r[1] - r[0] + 1;\n    }\n\n    return result;\n  };\n  /**\n   * Checks if two instances of MultiRange are identical.\n   * @param cmp The data to compare.\n   * @return True if cmp is exactly the same as this instance.\n   */\n\n\n  MultiRange.prototype.equals = function (cmp) {\n    if (cmp === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (cmp instanceof MultiRange) {\n      if (cmp === this) return true;\n      if (this.ranges.length !== cmp.ranges.length) return false;\n\n      for (var i = 0; i < this.ranges.length; i++) {\n        if (this.ranges[i][0] !== cmp.ranges[i][0] || this.ranges[i][1] !== cmp.ranges[i][1]) return false;\n      }\n\n      return true;\n    } else {\n      return this.equals(new MultiRange(cmp));\n    }\n  };\n  /**\n   * Checks if the current instance is unbounded (i.e., infinite).\n   */\n\n\n  MultiRange.prototype.isUnbounded = function () {\n    return this.ranges.length > 0 && (this.ranges[0][0] === -Infinity || this.ranges[this.ranges.length - 1][1] === Infinity);\n  };\n  /**\n   * Returns the minimum number contained in this insntance. Can be -Infinity or undefined.\n   */\n\n\n  MultiRange.prototype.min = function () {\n    if (this.ranges.length === 0) return undefined;\n    return this.ranges[0][0];\n  };\n  /**\n   * Returns the maximum number contained in this insntance. Can be +Infinity or undefined.\n   */\n\n\n  MultiRange.prototype.max = function () {\n    if (this.ranges.length === 0) return undefined;\n    return this.ranges[this.ranges.length - 1][1];\n  };\n  /**\n   * Removes the smallest integer from this instance and returns that integer.\n   */\n\n\n  MultiRange.prototype.shift = function () {\n    var min = this.min();\n    if (min === -Infinity) throw new RangeError('shift() was invoked on an unbounded MultiRange which contains -Infinity');\n    if (min !== undefined) this.subtract(min);\n    return min;\n  };\n  /**\n   * Removes the largest integer from this instance and returns that integer.\n   */\n\n\n  MultiRange.prototype.pop = function () {\n    var max = this.max();\n    if (max === Infinity) throw new RangeError('pop() was invoked on an unbounded MultiRange which contains +Infinity');\n    if (max !== undefined) this.subtract(max);\n    return max;\n  };\n  /**\n   * Returns the string respresentation of this MultiRange.\n   */\n\n\n  MultiRange.prototype.toString = function () {\n    function wrap(i) {\n      return i >= 0 ? String(i) : \"(\" + i + \")\";\n    }\n\n    var ranges = [];\n\n    for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n      var r = _a[_i];\n\n      if (r[0] === -Infinity) {\n        if (r[1] === Infinity) {\n          ranges.push('-');\n        } else {\n          ranges.push(\"-\" + wrap(r[1]));\n        }\n      } else if (r[1] === Infinity) {\n        ranges.push(wrap(r[0]) + \"-\");\n      } else if (r[0] == r[1]) {\n        ranges.push(wrap(r[0]));\n      } else {\n        ranges.push(wrap(r[0]) + \"-\" + wrap(r[1]));\n      }\n    }\n\n    return ranges.join(',');\n  };\n  /**\n   * Builds an array of integer which holds all elements in this MultiRange.\n   * Note that this may be slow and memory-consuming for large ranges such as '1-10000'.\n   */\n\n\n  MultiRange.prototype.toArray = function () {\n    if (this.isUnbounded()) {\n      throw new RangeError('You cannot build an array from an unbounded range');\n    }\n\n    var result = new Array(this.length());\n    var idx = 0;\n\n    for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n      var r = _a[_i];\n\n      for (var n = r[0]; n <= r[1]; n++) {\n        result[idx++] = n;\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Returns ES6-compatible iterator.\n   */\n\n\n  MultiRange.prototype.getIterator = function () {\n    var _this = this;\n\n    if (this.isUnbounded()) {\n      throw new RangeError('Unbounded ranges cannot be iterated over');\n    }\n\n    var i = 0,\n        curRange = this.ranges[i],\n        j = curRange ? curRange[0] : undefined;\n    return {\n      next: function () {\n        if (!curRange) return {\n          done: true\n        };\n        var ret = j;\n\n        if (++j > curRange[1]) {\n          curRange = _this.ranges[++i];\n          j = curRange ? curRange[0] : undefined;\n        }\n\n        return {\n          value: ret\n        };\n      }\n    };\n  };\n\n  return MultiRange;\n}();\n\nexports.MultiRange = MultiRange; // Set ES6 iterator, if Symbol.iterator is defined\n\n/* istanbul ignore else */\n\nif (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n  MultiRange.prototype[Symbol.iterator] = MultiRange.prototype.getIterator;\n} // A shorthand function to get a new MultiRange instance\n\n\nfunction multirange(data) {\n  return new MultiRange(data);\n}\n\nexports.multirange = multirange;","map":null,"metadata":{},"sourceType":"script"}