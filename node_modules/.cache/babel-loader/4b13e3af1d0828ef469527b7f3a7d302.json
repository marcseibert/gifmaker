{"ast":null,"code":"var MultiRange = require('multi-integer-range').MultiRange;\n\nvar getPixels = require('get-pixels-frame-info-update');\n\nvar savePixels = require('save-pixels-jpeg-js-upgrade');\n\nfunction nopromises() {\n  throw new Error('Promises not supported in your environment. ' + 'Use the callback argument or a Promise polyfill.');\n}\n\nvar brokenPromise = {\n  then: nopromises,\n  catch: nopromises\n};\n\nfunction gifFrames(options, callback) {\n  options = options || {};\n\n  callback = callback || function () {};\n\n  var promise;\n  var resolve;\n  var reject;\n\n  if (typeof Promise === 'function') {\n    promise = new Promise(function (_resolve, _reject) {\n      resolve = function (res) {\n        callback(null, res);\n\n        _resolve(res);\n      };\n\n      reject = function (err) {\n        callback(err);\n\n        _reject(err);\n      };\n    });\n  } else {\n    promise = brokenPromise;\n\n    resolve = function (res) {\n      callback(null, res);\n    };\n\n    reject = callback;\n  }\n\n  var url = options.url;\n\n  if (!url) {\n    reject(new Error('\"url\" option is required.'));\n    return promise;\n  }\n\n  var frames = options.frames;\n\n  if (!frames && frames !== 0) {\n    reject(new Error('\"frames\" option is required.'));\n    return promise;\n  }\n\n  var outputType = options.outputType || 'jpg';\n  var quality = options.quality;\n  var cumulative = options.cumulative;\n  var acceptedFrames = frames === 'all' ? 'all' : new MultiRange(frames); // Necessary to check if we're in Node or the browser until this is fixed:\n  // https://github.com/scijs/get-pixels/issues/33\n\n  var inputType = typeof window === 'undefined' ? 'image/gif' : '.GIF';\n  getPixels(url, inputType, function (err, pixels, framesInfo) {\n    if (err) {\n      reject(err);\n      return;\n    }\n\n    if (pixels.shape.length < 4) {\n      reject(new Error('\"url\" input should be multi-frame GIF.'));\n      return;\n    }\n\n    var frameData = [];\n    var maxAccumulatedFrame = 0;\n\n    for (var i = 0; i < pixels.shape[0]; i++) {\n      if (acceptedFrames !== 'all' && !acceptedFrames.has(i)) {\n        continue;\n      }\n\n      (function (frameIndex) {\n        frameData.push({\n          getImage: function () {\n            if (cumulative && frameIndex > maxAccumulatedFrame) {\n              // for each frame, replace any invisible pixel with\n              // the corresponding pixel from the previous frame (beginning\n              // with the second frame).\n              // to avoid doing too much work at once we only compute the\n              // frames up to and including the requested frame.\n              var lastFrame = pixels.pick(maxAccumulatedFrame);\n\n              for (var f = maxAccumulatedFrame + 1; f <= frameIndex; f++) {\n                var frame = pixels.pick(f);\n\n                for (var x = 0; x < frame.shape[0]; x++) {\n                  for (var y = 0; y < frame.shape[1]; y++) {\n                    if (frame.get(x, y, 3) === 0) {\n                      // if alpha is fully transparent, use the pixel\n                      // from the last frame\n                      frame.set(x, y, 0, lastFrame.get(x, y, 0));\n                      frame.set(x, y, 1, lastFrame.get(x, y, 1));\n                      frame.set(x, y, 2, lastFrame.get(x, y, 2));\n                      frame.set(x, y, 3, lastFrame.get(x, y, 3));\n                    }\n                  }\n                }\n\n                lastFrame = frame;\n              }\n\n              maxAccumulatedFrame = frameIndex;\n            }\n\n            return savePixels(pixels.pick(frameIndex), outputType, {\n              quality: quality\n            });\n          },\n          frameIndex: frameIndex,\n          frameInfo: framesInfo && framesInfo[frameIndex]\n        });\n      })(i);\n    }\n\n    resolve(frameData);\n  });\n  return promise;\n}\n\nmodule.exports = gifFrames;","map":null,"metadata":{},"sourceType":"script"}